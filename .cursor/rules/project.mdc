---
description: Enhanced project rules for the skv Go CLI application with AI-specific guidance.
globs:
  - "**/*.go"
  - "**/*.md"
  - "**/*.yaml"
  - "**/*.yml"
  - "**/*.sh"
alwaysApply: true
---

# ğŸ” **`skv` Project Rules for AI Agents**

This document provides comprehensive guidance for AI agents (like Claude Sonnet) working on the `skv` project. These rules ensure consistent, secure, and maintainable code.

## ğŸ¯ **1. Core Principles**

### **Security First** ğŸ›¡ï¸

- **Primary Goal**: Handle secrets securely at all times
- **Never log secrets**: Use masking, redaction, or avoid logging entirely
- **Memory-only operations**: Secrets should never be written to disk
- **Fail-safe design**: Prefer failing securely over potentially exposing data
- **Input validation**: Always validate and sanitize inputs, especially from config files

### **Simplicity and Reliability** âœ¨

- **Intuitive CLI**: Commands should be self-explanatory with helpful error messages
- **Graceful degradation**: Handle missing dependencies or network issues gracefully
- **Clear error messages**: Provide actionable guidance when things go wrong
- **Consistent behavior**: Similar operations should work similarly across providers

### **Extensibility** ğŸ”Œ

- **Provider pattern**: New secret providers should integrate seamlessly
- **Minimal interface**: Keep the `Provider` interface as simple as possible
- **Configuration-driven**: Behavior should be configurable rather than hardcoded
- **Backwards compatibility**: Maintain compatibility when adding features

### **Maintainability** ğŸ§¹

- **Clean code**: Follow Go idioms and conventions
- **Comprehensive docs**: All exported items need clear GoDoc comments
- **Test coverage**: Aim for >70% coverage, 100% for critical paths
- **Professional formatting**: Use clear, professional comments in code; emojis are acceptable in documentation

## ğŸ—ï¸ **2. Architecture and Structure**

### **Project Layout**

```
skv/
â”œâ”€â”€ cmd/skv/                    # ğŸ¯ CLI entry point and commands
â”‚   â”œâ”€â”€ main.go                # ğŸš€ Application bootstrap and provider registration
â”‚   â”œâ”€â”€ get.go, run.go, etc.   # ğŸ’» Individual command implementations
â”‚   â””â”€â”€ *_test.go              # ğŸ§ª Command-level tests
â”œâ”€â”€ internal/
â”‚   â”œâ”€â”€ config/                # âš™ï¸ Configuration loading and validation
â”‚   â”œâ”€â”€ provider/              # ğŸ”Œ Provider interface and implementations
â”‚   â”‚   â”œâ”€â”€ aws/               # â˜ï¸ AWS Secrets Manager & SSM
â”‚   â”‚   â”œâ”€â”€ gcp/               # ğŸŒ Google Secret Manager
â”‚   â”‚   â”œâ”€â”€ azure/             # ğŸ”· Azure Key Vault & App Config
â”‚   â”‚   â”œâ”€â”€ vault/             # ğŸ—„ï¸ HashiCorp Vault
â”‚   â”‚   â”œâ”€â”€ exec/              # ğŸ”§ External command execution
â”‚   â”‚   â””â”€â”€ mock/              # ğŸ­ Testing mock provider
â”‚   â””â”€â”€ version/               # ğŸ“¦ Build-time version information
â”œâ”€â”€ docs/                      # ğŸ“š User and developer documentation
â”‚   â”œâ”€â”€ dev/                   # ğŸ› ï¸ Developer-specific docs
â”‚   â””â”€â”€ *.md                   # ğŸ“– User guides and references
â””â”€â”€ scripts/                   # ğŸ”§ Build and development scripts
```

### **Key Components**

- **CLI Commands**: Each command is a separate file with focused responsibility
- **Provider Registry**: Central registration in `main.go` with multiple aliases
- **Configuration**: YAML-based with environment variable interpolation
- **Testing**: Unit tests alongside implementation files, E2E tests in `cmd/skv/`

## ğŸ¹ **3. Go Best Practices**

### **Error Handling** âš ï¸

```go
// âœ… Correct: Wrap errors with context
_, err := client.FetchSecret()
if err != nil {
    return fmt.Errorf("ğŸ”‘ failed to fetch secret from %s provider: %w", providerName, err)
}

// âŒ Incorrect: Lose error context
_, err := client.FetchSecret()
if err != nil {
    log.Fatal(err) // Hides the original error context
}
```

### **Concurrency** âš¡

- Use `sync.Mutex` for protecting shared state
- Use `chan` for goroutine communication
- Avoid global variables; pass context explicitly
- Always use `context.Context` for cancellation and timeouts

### **Testing** ğŸ§ª

- **Unit tests**: Test individual functions and methods
- **Integration tests**: Test provider interactions (with mocking)
- **E2E tests**: Test complete workflows end-to-end
- **Table-driven tests**: Use for testing multiple scenarios
- **Race detection**: Always run `go test -race`

### **Documentation** ğŸ“

```go
// ğŸ”‘ FetchSecret retrieves a secret value from the provider.
// It returns the secret value or an error if the secret cannot be retrieved.
// The context can be used for cancellation and timeout control.
func (p *provider) FetchSecret(ctx context.Context, spec SecretSpec) (string, error) {
    // Implementation
}
```

### **Code Style** ğŸ¨

- **Comments**: Use clear, professional language without emojis
- **Error messages**: Focus on clarity and actionable information
- **Documentation**: Emojis are acceptable for visual organization
- **Logs**: Keep professional, avoid emojis in production logs

## ğŸ”Œ **4. Provider Interface**

### **Core Interface**

```go
// ğŸ”‘ Provider fetches a secret value by spec.
type Provider interface {
    FetchSecret(ctx context.Context, spec SecretSpec) (string, error)
}

// ğŸ“‹ SecretSpec is an immutable specification for a secret fetch.
type SecretSpec struct {
    Alias    string            // ğŸ·ï¸ Human-readable alias for the secret
    Name     string            // ğŸ“ Provider-specific secret name/path
    Provider string            // ğŸ”Œ Provider type (aws, gcp, azure, etc.)
    EnvName  string            // ğŸŒ Environment variable name
    Extras   map[string]string // âš™ï¸ Provider-specific configuration options
}
```

### **Provider Implementation Guidelines**

- **Registration**: Register in `main.go` with descriptive aliases
- **Error handling**: Return `provider.ErrNotFound` for missing secrets
- **Context usage**: Respect context cancellation and timeouts
- **Configuration**: Use `spec.Extras` for provider-specific options
- **Testing**: Include both unit and integration tests

### **Common Extras Options**

- `region`: AWS region, GCP zone, Azure location
- `profile`: AWS profile, credential profile name
- `project`: GCP project ID
- `vault_url`: HashiCorp Vault server URL
- `namespace`: Vault namespace or similar
- `version`: Secret version (if supported)

## ğŸ§ª **5. Testing Guidelines**

### **Test Structure**

```go
func TestProviderFetchSecret(t *testing.T) {
    tests := []struct {
        name    string
        spec    provider.SecretSpec
        want    string
        wantErr bool
    }{
        {
            name: "ğŸ”‘ successful secret fetch",
            spec: provider.SecretSpec{
                Name: "test-secret",
                Extras: map[string]string{"region": "us-east-1"},
            },
            want:    "secret-value",
            wantErr: false,
        },
        {
            name: "âŒ secret not found",
            spec: provider.SecretSpec{Name: "nonexistent"},
            wantErr: true,
        },
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Test implementation
        })
    }
}
```

### **Test Coverage Requirements**

- **Critical paths**: 100% coverage (secret fetching, error handling)
- **Overall project**: >70% coverage
- **New features**: Must include comprehensive tests
- **Edge cases**: Test error conditions, timeouts, cancellation

## ğŸ”’ **6. Security Requirements**

### **Secret Handling**

- **Never log secrets**: Use masking or avoid logging
- **Memory-only**: No disk writes for secret values
- **Short-lived**: Minimize time secrets spend in memory
- **Secure cleanup**: Zero out memory when possible

### **Input Validation**

- **Configuration files**: Validate structure and required fields
- **Provider inputs**: Sanitize and validate all provider-specific options
- **Command arguments**: Validate CLI arguments and flags
- **Environment variables**: Handle missing or invalid values gracefully

### **Error Messages**

- **No secret leakage**: Never include secret values in error messages
- **Helpful context**: Provide enough information for debugging
- **Security boundaries**: Don't expose internal system details

## ğŸ¯ **7. AI Agent Guidelines**

### **When Writing Code**

- **Follow style guide**: Use professional, clear comments without emojis
- **Security first**: Always consider security implications
- **Test thoroughly**: Include comprehensive tests with new code
- **Document clearly**: Explain complex logic and design decisions

### **When Refactoring**

- **Preserve behavior**: Maintain existing functionality
- **Improve incrementally**: Make small, focused changes
- **Update tests**: Ensure tests still pass and cover new scenarios
- **Update docs**: Keep documentation in sync with code changes

### **When Adding Features**

- **Provider pattern**: Follow existing provider implementation patterns
- **Configuration**: Make features configurable through YAML
- **Error handling**: Use consistent error handling patterns
- **Backwards compatibility**: Don't break existing configurations

### **Common Patterns to Follow**

- **Context propagation**: Always pass context through call chains
- **Error wrapping**: Use `fmt.Errorf("context: %w", err)` pattern
- **Table-driven tests**: Use for testing multiple scenarios
- **Interface segregation**: Keep interfaces minimal and focused

## ğŸ“‹ **8. Code Review Checklist**

### **Before Submitting**

- [ ] ğŸ§ª All tests pass (`go test ./...`)
- [ ] ğŸ” Linting passes (`golangci-lint run`)
- [ ] ğŸ“Š Coverage maintained or improved
- [ ] ğŸ“ Documentation updated
- [ ] ğŸ”’ Security implications considered
- [ ] âš¡ Performance impact assessed
- [ ] ğŸ¨ Professional formatting applied consistently

### **Architecture Review**

- [ ] ğŸ—ï¸ Follows established patterns
- [ ] ğŸ”Œ Provider interface properly implemented
- [ ] âš™ï¸ Configuration properly handled
- [ ] ğŸ”„ Error handling consistent
- [ ] ğŸ§¹ No code duplication

This document serves as the definitive guide for AI agents working on the `skv` project. Following these rules ensures high-quality, secure, and maintainable code.
